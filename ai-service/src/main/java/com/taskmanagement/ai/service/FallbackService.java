package com.taskmanagement.ai.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

@Service
@Slf4j
public class FallbackService {

    private final AtomicLong fallbackCounter = new AtomicLong(0);
    
    @Value("${ai.fallback.enabled:true}")
    private boolean fallbackEnabled;

    public Map<String, Object> parseTaskFallback(Map<String, String> request) {
        long fallbackCount = fallbackCounter.incrementAndGet();
        log.warn("FALLBACK ACTIVATED: Task parsing fallback used (count: {}). Python AI service unavailable.", fallbackCount);
        
        if (!fallbackEnabled) {
            log.error("Fallback is disabled but was called for task parsing");
            throw new RuntimeException("Fallback service is disabled and Python AI service is unavailable");
        }
        
        String taskText = request.get("text");
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        
        Map<String, Object> response = Map.of(
            "title", extractTitle(taskText),
            "description", taskText != null ? taskText : "No description provided",
            "priority", determineFallbackPriority(taskText),
            "estimatedHours", estimateFallbackHours(taskText),
            "tags", new String[]{"fallback-parsed", "degraded-service"},
            "confidence", 0.5,
            "source", "fallback",
            "fallbackCount", fallbackCount,
            "timestamp", timestamp,
            "message", "⚠️ Response generated by fallback service - Python AI service unavailable. Limited functionality."
        );
        
        log.info("Fallback task parsing completed for request: {}", taskText);
        return response;
    }

    public Map<String, Object> prioritizeTasksFallback(Map<String, Object> request) {
        long fallbackCount = fallbackCounter.incrementAndGet();
        log.warn("FALLBACK ACTIVATED: Task prioritization fallback used (count: {}). Python AI service unavailable.", fallbackCount);
        
        if (!fallbackEnabled) {
            log.error("Fallback is disabled but was called for task prioritization");
            throw new RuntimeException("Fallback service is disabled and Python AI service is unavailable");
        }
        
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        
        // Basic fallback prioritization logic
        List<?> tasks = (List<?>) request.get("tasks");
        String[] prioritizedTasks = tasks != null ? 
            tasks.stream().map(Object::toString).toArray(String[]::new) :
            new String[]{"No tasks provided"};
        
        Map<String, Object> response = Map.of(
            "prioritizedTasks", prioritizedTasks,
            "reasoning", "⚠️ Basic alphabetical ordering applied - Python AI service unavailable. For intelligent prioritization, ensure Python AI service is running.",
            "confidence", 0.3,
            "source", "fallback",
            "fallbackCount", fallbackCount,
            "timestamp", timestamp,
            "message", "⚠️ Response generated by fallback service - Python AI service unavailable. Limited functionality."
        );
        
        log.info("Fallback task prioritization completed");
        return response;
    }

    public Map<String, Object> getInsightsFallback() {
        long fallbackCount = fallbackCounter.incrementAndGet();
        log.warn("FALLBACK ACTIVATED: Productivity insights fallback used (count: {}). Python AI service unavailable.", fallbackCount);
        
        if (!fallbackEnabled) {
            log.error("Fallback is disabled but was called for productivity insights");
            throw new RuntimeException("Fallback service is disabled and Python AI service is unavailable");
        }
        
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        
        Map<String, Object> response = Map.of(
            "insights", new String[]{
                "⚠️ Generic productivity insights (fallback mode)",
                "Consider organizing tasks by priority and deadline",
                "Break large tasks into smaller, manageable chunks",
                "Regular breaks can improve focus and productivity"
            },
            "recommendations", new String[]{
                "⚠️ Generic recommendations (fallback mode)",
                "Use time-blocking techniques for better focus",
                "Review and adjust your task priorities regularly",
                "Consider using productivity tools and techniques"
            },
            "confidence", 0.2,
            "source", "fallback",
            "fallbackCount", fallbackCount,
            "timestamp", timestamp,
            "message", "⚠️ Response generated by fallback service - Python AI service unavailable. For personalized insights, ensure Python AI service is running."
        );
        
        log.info("Fallback productivity insights completed");
        return response;
    }

    private String extractTitle(String text) {
        if (text == null || text.trim().isEmpty()) {
            return "Untitled Task (Fallback)";
        }
        
        String[] words = text.trim().split("\\s+");
        if (words.length <= 5) {
            return text.trim();
        }
        
        return String.join(" ", java.util.Arrays.copyOf(words, 5)) + "...";
    }

    private String determineFallbackPriority(String text) {
        if (text == null) return "MEDIUM";
        
        String lowerText = text.toLowerCase();
        if (lowerText.contains("urgent") || lowerText.contains("asap") || lowerText.contains("critical")) {
            return "HIGH";
        } else if (lowerText.contains("later") || lowerText.contains("someday") || lowerText.contains("maybe")) {
            return "LOW";
        }
        return "MEDIUM";
    }

    private int estimateFallbackHours(String text) {
        if (text == null) return 2;
        
        int wordCount = text.split("\\s+").length;
        if (wordCount < 5) return 1;
        if (wordCount < 15) return 2;
        if (wordCount < 30) return 4;
        return 8;
    }

    public long getFallbackUsageCount() {
        return fallbackCounter.get();
    }

    public void resetFallbackCounter() {
        fallbackCounter.set(0);
        log.info("Fallback usage counter reset");
    }
}